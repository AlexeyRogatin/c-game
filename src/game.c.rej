diff a/src/game.c b/src/game.c	(rejected hunks)
@@ -462,152 +462,156 @@
 
     f32 speedLength = length(ourObject->speed);
 
-    if (speedLength)
+    bool collisionXHappened = false;
+    bool collisionYHappened = false;
+
+    i32 ratioIndex = 1;
+    while (speedLength / ratioIndex > TILE_SIZE_PIXELS)
     {
-        bool collisionXHappened = false;
-        bool collisionYHappened = false;
+        ratioIndex++;
+    }
 
-        i32 ratioIndex = 1;
-        while (speedLength / ratioIndex > TILE_SIZE_PIXELS)
-        {
-            ratioIndex++;
-        }
+    f32 ratioChange = (speedLength / ratioIndex) / speedLength;
 
-        f32 ratioChange = (speedLength / ratioIndex) / speedLength;
+    f32 ratio = ratioChange;
+    V2 speedUnit = unit(ourObject->speed);
 
-        f32 ratio = ratioChange;
-        V2 speedUnit = unit(ourObject->speed);
+    while (ratio <= 1)
+    {
+        V2 speedPart = speedUnit * ratio * speedLength;
 
-        while (ratio <= 1)
-        {
-            V2 speedPart = speedUnit * ratio * speedLength;
+        //стороны объекта
+        i32 objLeft = ourObject->pos.x - (ourObject->hitBox.x / 2);
+        i32 objRight = ourObject->pos.x + (ourObject->hitBox.x / 2);
+        i32 objBottom = ourObject->pos.y - (ourObject->hitBox.y / 2);
+        i32 objTop = ourObject->pos.y + (ourObject->hitBox.y / 2);
 
-            //стороны объекта
-            i32 objLeft = ourObject->pos.x - (ourObject->hitBox.x / 2);
-            i32 objRight = ourObject->pos.x + (ourObject->hitBox.x / 2);
-            i32 objBottom = ourObject->pos.y - (ourObject->hitBox.y / 2);
-            i32 objTop = ourObject->pos.y + (ourObject->hitBox.y / 2);
+        i32 recentObjLeft = ourObject->pos.x - (ourObject->recentHitBox.x / 2);
+        i32 recentObjRight = ourObject->pos.x + (ourObject->recentHitBox.x / 2);
+        i32 recentObjBottom = ourObject->pos.y - (ourObject->recentHitBox.y / 2);
+        i32 recentObjTop = ourObject->pos.y + (ourObject->recentHitBox.y / 2);
 
-            V2 objTilePos = {roundf((ourObject->pos.x + speedPart.x) / TILE_SIZE_PIXELS),
-                             roundf((ourObject->pos.y + speedPart.y) / TILE_SIZE_PIXELS)};
+        V2 objTilePos = {roundf((ourObject->pos.x + speedPart.x) / TILE_SIZE_PIXELS),
+                         roundf((ourObject->pos.y + speedPart.y) / TILE_SIZE_PIXELS)};
 
-            //проверка столкновений с тайлами
-            for (i32 x = (i32)objTilePos.x - 2; x < (i32)objTilePos.x + 2; x++)
+        //проверка столкновений с тайлами
+        for (i32 x = (i32)objTilePos.x - 2; x < (i32)objTilePos.x + 2; x++)
+        {
+            for (i32 y = (i32)objTilePos.y - 2; y < (i32)objTilePos.y + 2; y++)
             {
-                for (i32 y = (i32)objTilePos.y - 2; y < (i32)objTilePos.y + 2; y++)
+                i32 tileIndex = y * CHUNK_SIZE_X * (CHUNK_COUNT_X + 2) + x;
+                Tile_Type tile = tiles[tileIndex];
+                V2 tilePos = getTilePos(tileIndex);
+                if (tile && (tile == Tile_Type_WALL || tile == Tile_Type_BORDER))
                 {
-                    i32 tileIndex = y * CHUNK_SIZE_X * (CHUNK_COUNT_X + 2) + x;
-                    Tile_Type tile = tiles[tileIndex];
-                    V2 tilePos = getTilePos(tileIndex);
-                    if (tile && (tile == Tile_Type_WALL || tile == Tile_Type_BORDER))
-                    {
-                        i32 tileLeft = tilePos.x * TILE_SIZE_PIXELS - TILE_SIZE_PIXELS / 2;
-                        i32 tileRight = tilePos.x * TILE_SIZE_PIXELS + TILE_SIZE_PIXELS / 2;
-                        i32 tileBottom = tilePos.y * TILE_SIZE_PIXELS - TILE_SIZE_PIXELS / 2;
-                        i32 tileTop = tilePos.y * TILE_SIZE_PIXELS + TILE_SIZE_PIXELS / 2;
+                    i32 tileLeft = tilePos.x * TILE_SIZE_PIXELS - TILE_SIZE_PIXELS / 2;
+                    i32 tileRight = tilePos.x * TILE_SIZE_PIXELS + TILE_SIZE_PIXELS / 2;
+                    i32 tileBottom = tilePos.y * TILE_SIZE_PIXELS - TILE_SIZE_PIXELS / 2;
+                    i32 tileTop = tilePos.y * TILE_SIZE_PIXELS + TILE_SIZE_PIXELS / 2;
 
-                        i32 objSide;
-                        i32 tileSide;
+                    i32 objSide;
+                    i32 tileSide;
 
-                        if (speedPart.y != 0)
+                    if (speedUnit.y != 0)
+                    {
+                        if (speedUnit.y > 0)
                         {
-                            if (speedPart.y > 0)
-                            {
-                                objSide = objTop;
-                                tileSide = tileBottom;
-                            }
-                            else
-                            {
-                                objSide = objBottom;
-                                tileSide = tileTop;
-                            }
+                            objSide = objTop;
+                            tileSide = tileBottom;
+                        }
+                        else
+                        {
+                            objSide = objBottom;
+                            tileSide = tileTop;
+                        }
 
-                            if (
-                                !(objTop + speedPart.y <= tileBottom ||
-                                  objBottom + speedPart.y >= tileTop ||
-                                  objRight <= tileLeft ||
-                                  objLeft >= tileRight))
-                            {
-                                ourObject->speed.y = 0;
-                                speedPart.y = 0;
-                                speedUnit.y = 0;
+                        if (
+                            !(recentObjTop + speedPart.y <= tileBottom ||
+                              recentObjBottom + speedPart.y >= tileTop ||
+                              recentObjRight <= tileLeft ||
+                              recentObjLeft >= tileRight))
+                        {
+                            gameObject->speed.y = unit(gameObject->speed).y;
+                            ourObject->speed.y = 0;
+                            speedUnit.y = 0;
 
-                                ourObject->pos.y -= objSide - tileSide;
+                            ourObject->pos.y -= objSide - tileSide;
 
-                                collisionYHappened = true;
+                            collisionYHappened = true;
 
-                                if (tileSide == tileBottom)
-                                {
-                                    timers[ourObject->canIncreaseJump] = 0;
-                                }
+                            if (tileSide == tileBottom)
+                            {
+                                timers[ourObject->canIncreaseJump] = 0;
                             }
                         }
+                    }
 
-                        if (collisionYHappened && tileSide == tileTop && ourObject->condition != HANGING)
+                    if (collisionYHappened && tileSide == tileTop && ourObject->condition != HANGING)
+                    {
+                        ourObject->condition = IDLE;
+                        timers[ourObject->canJump] = 3;
+                    }
+
+                    if (speedUnit.x != 0)
+                    {
+                        if (speedUnit.x > 0)
+                        {
+                            objSide = objRight;
+                            tileSide = tileLeft;
+                        }
+                        else
                         {
-                            ourObject->condition = IDLE;
-                            timers[ourObject->canJump] = 3;
+                            objSide = objLeft;
+                            tileSide = tileRight;
                         }
 
-                        if (speedPart.x != 0)
+                        if (
+                            !(recentObjRight + speedPart.x <= tileLeft ||
+                              recentObjLeft + speedPart.x >= tileRight ||
+                              recentObjTop <= tileBottom ||
+                              recentObjBottom >= tileTop))
                         {
-                            if (speedPart.x > 0)
-                            {
-                                objSide = objRight;
-                                tileSide = tileLeft;
-                            }
-                            else
-                            {
-                                objSide = objLeft;
-                                tileSide = tileRight;
-                            }
 
-                            if (
-                                !(objRight + speedPart.x < tileLeft ||
-                                  objLeft + speedPart.x > tileRight ||
-                                  objTop <= tileBottom ||
-                                  objBottom >= tileTop))
+                            gameObject->speed.x = unit(gameObject->speed).x;
+                            ourObject->speed.x = 0;
+                            speedUnit.x = 0;
+                            ourObject->pos.x -= objSide - tileSide;
+                            collisionXHappened = true;
+
+                            i32 upTileIndex = (y + 1) * CHUNK_SIZE_X * (CHUNK_COUNT_X + 2) + x;
+
+                            if (tile_map[upTileIndex] == Tile_Type_NONE)
                             {
+                                //весит
+                                if (ourObject->type == PLAYER && ourObject->speed.y < 0 && ourObject->pos.y >= tilePos.y * TILE_SIZE_PIXELS && ourObject->pos.y + ourObject->speed.y <= tilePos.y * TILE_SIZE_PIXELS)
+                                {
+                                    ourObject->condition = HANGING;
 
-                                ourObject->speed.x = 0;
-                                speedPart.x = 0;
-                                speedUnit.x = 0;
-                                ourObject->pos.x -= objSide - tileSide;
-                                collisionXHappened = true;
+                                    gameObject->speed.y = unit(gameObject->speed).y;
+                                    ourObject->speed.y = 0;
+                                    speedUnit.y = 0;
 
-                                i32 upTileIndex = (y + 1) * CHUNK_SIZE_X * (CHUNK_COUNT_X + 2) + x;
+                                    ourObject->pos.y = tilePos.y * TILE_SIZE_PIXELS;
+                                    collisionYHappened = true;
+                                }
 
-                                if (tile_map[upTileIndex] == Tile_Type_NONE)
+                                //помощь в карабкании
+                                if (objBottom < tileTop && objBottom + 12 > tileTop)
                                 {
-                                    //весит
-                                    if (ourObject->type == PLAYER && ourObject->speed.y < 0 && ourObject->pos.y > tilePos.y * TILE_SIZE_PIXELS && ourObject->pos.y + ourObject->speed.y < tilePos.y * TILE_SIZE_PIXELS)
-                                    {
-                                        ourObject->condition = HANGING;
-                                        ourObject->speed.y = 0;
-                                        speedPart.y = 0;
-                                        speedUnit.y = 0;
-                                        ourObject->pos.y = tilePos.y * TILE_SIZE_PIXELS;
-                                        collisionYHappened = true;
-                                    }
-
-                                    //помощь в карабкании
-                                    if (objBottom < tileTop && objBottom + 10 > tileTop)
-                                    {
-                                        ourObject->speed.y += 5;
-                                    }
+                                    ourObject->speed.y += 5;
                                 }
                             }
                         }
                     }
                 }
             }
-            ratio += ratioChange;
         }
-        gameObject->pos = ourObject->pos;
-        gameObject->pos += ourObject->speed;
-        gameObject->condition = ourObject->condition;
-        gameObject->canJump = ourObject->canJump;
+        ratio += ratioChange;
     }
+    gameObject->pos = ourObject->pos;
+    gameObject->pos += ourObject->speed;
+    gameObject->condition = ourObject->condition;
+    gameObject->canJump = ourObject->canJump;
 }
 
 void updateGameObject(Game_Object *gameObject, Input input, Bitmap screen)
